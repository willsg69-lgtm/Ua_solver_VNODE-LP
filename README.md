# Ua_solver_VNODE-LP
The code was created by Gemini 2.5 Pro based on these instructions:
Consider the ODE a'(r)=r*(1-U(r)^2)/2, U'(r)=(1-a(r))*U(r)/r for r>0. Write a C++ code relying on the VNODE-LP library to accomplish the following tasks: I need to solve this from r=r_0>0, taken from the interval I_0:=[0.05,0.2]  to r=r_1:=100 to 50 digits of precision with initial conditions that depend on some parameter k>0. I know that k lies in J_0:=[k_0,k_1] where k_0=0.60 and k_1=0.61. The initial values (U(r_0),a(r_0)) are computed from a Taylor polynomial U(r)=k*r-c_1(k)*r^3+c_2(k)*r^5-... +(-1)^N c_N(k)*r^(2N) and a(r)=r^2/4-d_1(k)*r^4 +d_2(k)*r^6-d_3(k)*r^8+...+(-1)^N d_N(k)*r^(2N). Take N=15, and include code that solves for all the 30 coefficients c_1(k), d_1(k) etc recursively to satisfy the ODE near r=0 as in the Frobenius method. Partition  the interval I_0 into 10 equally long parts and repeat the following computation for r_0 equal to the left endpoint of each of these 10 intervals: We want to run a bisection method on J_0 to determine as many significant digits of k as possible as follows. Picking k=k_0, solve the ODE with the specified initial data at that r_0 and that k=(k0+k1)/2 as stated above, from r_0 to r_1.  The solver should terminate as soon as a(r)>1 or U(r)>1. In the former case, it should replace k_0 by (k+k_1)/2 and keep k_1 as right endpoint. In the latter case, replace k_1 with (k_0+k)/2 and keep k_0 as left endpoint. This gives a new interval for k called J_1. Repeat the procedure with the midpoint of J_1 using the exact same dichotomy until we obtain an interval J_p after p steps whose length is less than 1e-50. Terminate at that p and let K_1,K_2,...,K_10 be the left endpoint of J_p for each of the 10 values of k_0 as specified above. The C++ code needs to output those 10 values of K_1,K_2,...,K_10 into a separate file called "ODE_results" together with the number of significant digits of k which are defined as the number of those digits of K_1,...,K_10 behind the comma that are all the same.   Finally, for k equal to the value of K_1 truncated to the number of significant digits it should compute and store the solutions (U(r), a(r))  from r_init=0.01 all the way to  some value of r=r_final which is the minimum of 50 or the value of r_init< r<50 at which either  a(r)>1 or U(r)>1. Use the Taylor polynomials as stated above to obtain the initial values of U(r), a(r) at r=r_init. It should state and store the value of r_final in the file "ODE_results" as well. That file "ODE_results"  also must state the relative errors of both U(r) and a(r) over the interval [r_init, r_final], as can be obtained from the interval arithmetic of VNODE-LP. Finally, "ODE_results"  also must  contain the functions F(r):=(1-U(r))/BesselK(0,r) and G(r):=(1-a(r))/(r*BesselK(0,r)) over the interval [7, r_final] stored in a way that can be graphed by gnuplot. Store instructions in the same file on how to plot U(r), a(r), F(r) and G(r) over the specified intervals of r. 
